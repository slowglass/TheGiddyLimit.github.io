"use strict";const CREATURE_SUB_ENTRY_PROPS=["entries","headerEntries","footerEntries"];class AcConvert{static tryPostProcessAc(a,b,c){let d=[];const e=/^(\d+)( \((.*?)\))?$/.exec(a.ac.trim());if(!e)c&&c(a.ac,`${`${a.name} ${a.source} p${a.page}`.padEnd(48)} => ${a.ac}`),d.push(a.ac);else if(e[3]){const c=e[3];let f={ac:+e[1]},g=null;const h=[],i=StrUtil.COMMAS_NOT_IN_PARENTHESES_REGEX,j=c.split(i).map(a=>a.trim());j.forEach(c=>{const e=c.toLowerCase();switch(e){case"unarmored defense":case"suave defense":case"armor scraps":case"barding scraps":case"patchwork armor":case"see natural armor feature":case"barkskin trait":case"sylvan warrior":case"cage":case"chains":case"coin mail":case"crude armored coat":case"improvised armor":case"magic robes":case"makeshift armor":case"natural and mystic armor":case"padded armor":case"padded leather":case"parrying dagger":case"plant fiber armor":case"plus armor worn":case"rag armor":case"ring of protection +2":case"see below":case"wicker armor":case"bone armor":h.push(c);break;case"natural armor":case"natural":h.push("natural armor");break;case"foresight bonus":h.push(`{@spell foresight} bonus`);break;case"natural barkskin":h.push(`natural {@spell barkskin}`);break;case"mage armor":h.push("{@spell mage armor}");break;case"studded leather armor":case"studded leather":h.push("{@item studded leather armor|phb}");break;case"leather armor":case"leather":h.push("{@item leather armor|phb}");break;case"half plate":h.push("{@item half plate armor|phb}");break;case"splint":case"splint armor":h.push("{@item splint armor|phb}");break;case"chain mail":case"chainmail":case"chain armor":h.push("{@item chain mail|phb}");break;case"scale mail":case"scale armor":case"scale":h.push("{@item scale mail|phb}");break;case"hide armor":case"hide":h.push("{@item hide armor|phb}");break;case"chain shirt":h.push("{@item chain shirt|phb}");break;case"breastplate":h.push("{@item breastplate|phb}");break;case"ring mail":h.push("{@item ring mail|phb}");break;case"plate mail":case"platemail":case"plate":case"plate armor":case"full plate":h.push("{@item plate armor|phb}");break;case"shield":h.push("{@item shield|phb}");break;case"shields":h.push("{@item shield|phb|shields}");break;case"dwarven plate":h.push("{@item dwarven plate}");break;case"elven chain":h.push("{@item elven chain}");break;case"glamoured studded leather":h.push("{@item glamoured studded leather}");break;case"bracers of defense":h.push("{@item bracers of defense}");break;case"badge of the watch":h.push("{@item Badge of the Watch|wdh}");break;case"ring of protection":h.push("{@item ring of protection}");break;case"robe of the archmagi":h.push("{@item robe of the archmagi}");break;case"staff of power":h.push("{@item staff of power}");break;case"+3 plate armor":h.push("{@item plate armor +3||+3 plate armor}");break;case"half plate armor +1":h.push("{@item half plate armor +1||+1 half-plate armor}");break;case"scale mail +1":h.push("{@item scale mail +1||+1 scale mail}");break;case"scale mail +2":h.push("{@item scale mail +2||+2 scale mail}");break;case"splint mail +2":h.push("{@item splint armor +2||+2 splint armor}");break;case"studded leather armor +1":h.push("{@item studded leather armor +1||+1 studded leather armor}");break;case"+2 leather armor":h.push("{@item leather armor +2||+2 leather armor}");break;case"+3 leather armor":h.push("{@item leather armor +3||+3 leather armor}");break;default:if(e.endsWith("with mage armor")||e.endsWith("with barkskin")){const a=/(\d+) with (.*)/.exec(e);if(!a)throw new Error("Spell AC but no leading number?");let b=null;if("mage armor"===a[2])b=`{@spell mage armor}`;else if("barkskin"===a[2])b=`{@spell barkskin}`;else throw new Error(`Unhandled spell! ${a[2]}`);g={ac:+a[1],condition:`with ${b}`,braces:!0}}else b&&b(c,`AC requires manual checking: ${a.name} ${a.source} p${a.page}`),d.push(c);}}),h.length?(f.from=h,d.push(f)):d.push(f.ac),g&&d.push(g)}else d.push(+e[1]);a.ac=d}}class TagAttack{static tryTagAttacks(a,b){const c=c=>{a[c]&&a[c].forEach(a=>{if(a.entries){const c=JSON.stringify(a.entries,null,"\t"),d=c.replace(/([\t ]")((?:(?:[A-Z][a-z]*|or) )*Attack:) /g,(...a)=>{const c=a[2].toLowerCase();return TagAttack.MAP[c]?`${a[1]}${TagAttack.MAP[c]} `:(b&&b(a[2]),a[0])});a.entries=JSON.parse(d)}})};c("action"),c("reaction"),c("trait"),c("legendary"),c("variant")}}TagAttack.MAP={"melee weapon attack:":"{@atk mw}","ranged weapon attack:":"{@atk rw}","melee attack:":"{@atk m}","ranged attack:":"{@atk r}","area attack:":"{@atk a}","area weapon attack:":"{@atk aw}","melee spell attack:":"{@atk ms}","melee or ranged weapon attack:":"{@atk mw,rw}","ranged spell attack:":"{@atk rs}","melee or ranged spell attack:":"{@atk ms,rs}","melee or ranged attack:":"{@atk m,r}"};class TagHit{static tryTagHits(a){const b=b=>{a[b]&&a[b].forEach(a=>{if(a.entries){const b=JSON.stringify(a.entries,null,"\t"),c=b.replace(/Hit: /g,"{@h}");a.entries=JSON.parse(c)}})};b("action"),b("reaction"),b("trait"),b("legendary"),b("variant")}}class TagDc{static tryTagDcs(a){const b=b=>{a[b]&&(a[b]=a[b].map(a=>{const b=JSON.stringify(a,null,"\t"),c=b.replace(/DC (\d+)/g,"{@dc $1}");return JSON.parse(c)}))};b("action"),b("reaction"),b("trait"),b("legendary"),b("variant"),b("spellcasting")}}class TagCondition{static tryTagConditions(a){const b=b=>{a[b]&&a[b].forEach(a=>{CREATURE_SUB_ENTRY_PROPS.forEach(b=>{if(a[b]){let c=JSON.stringify(a[b],null,"\t");TagCondition._CONDITION_MATCHERS.forEach(a=>c=c.replace(a,(...a)=>`${a[1]}{@condition ${a[2]}}${a[3]}`)),a[b]=JSON.parse(c)}})})};b("action"),b("reaction"),b("trait"),b("legendary"),b("variant")}}TagCondition._CONDITIONS=["blinded","charmed","deafened","exhaustion","frightened","grappled","incapacitated","invisible","paralyzed","petrified","poisoned","prone","restrained","stunned","unconscious"],TagCondition._CONDITION_MATCHERS=TagCondition._CONDITIONS.map(a=>new RegExp(`([^\\w])(${a})([^\\w}|])`,"gi"));class AlignmentConvert{static tryConvertAlignment(a,b){const c=Object.values(AlignmentConvert.ALIGNMENTS).find(b=>{const c=b.regex.test(a.alignment);return b.regex.lastIndex=0,c});c?a.alignment=c.output:b&&b(a.alignment)}}AlignmentConvert.ALIGNMENTS={"lawful good":["L","G"],"neutral good":["N","G"],"chaotic good":["C","G"],"chaotic neutral":["C","N"],"lawful evil":["L","E"],"lawful neutral":["L","N"],"neutral evil":["N","E"],"chaotic evil":["C","E"],good:["G"],lawful:["L"],neutral:["N"],chaotic:["C"],evil:["E"],unaligned:["U"],"any alignment":["A"],"any non-good( alignment)?":["L","NX","C","NY","E"],"any non-lawful( alignment)?":["NX","C","G","NY","E"],"any non-evil( alignment)?":["L","NX","C","NY","G"],"any non-chaotic( alignment)?":["NX","L","G","NY","E"],"any chaotic( alignment)?":["C","G","NY","E"],"any evil( alignment)?":["L","NX","C","E"],"any lawful( alignment)?":["L","G","NY","E"],"any good( alignment)?":["L","NX","C","G"],"any neutral( alignment)?":["NX","NY","N"],"neutral good \\(50%\\) or neutral evil \\(50%\\)":[{alignment:["N","G"],chance:50},{alignment:["N","E"],chance:50}],"chaotic good \\(75%\\) or neutral evil \\(25%\\)":[{alignment:["C","G"],chance:75},{alignment:["N","E"],chance:25}],"chaotic good \\(75%\\) or chaotic evil \\(25%\\)":[{alignment:["C","G"],chance:75},{alignment:["C","E"],chance:25}],"chaotic good or chaotic neutral":[{alignment:["C","G"]},{alignment:["C","N"]}],"lawful neutral or lawful evil":[{alignment:["L","N"]},{alignment:["L","E"]}],"neutral evil \\(50%\\) or lawful evil \\(50%\\)":[{alignment:["N","E"],chance:50},{alignment:["L","E"],chance:50}]},Object.entries(AlignmentConvert.ALIGNMENTS).forEach(([a,b])=>{AlignmentConvert.ALIGNMENTS[a]={output:b,regex:RegExp(`^${a}$`)}});class TagUtil{static isNoneOrEmpty(a){return!!(a&&a.trim())&&!!TagUtil.NONE_EMPTY_REGEX.exec(a)}}TagUtil.NONE_EMPTY_REGEX=/^(([-\u2014\u2013\u2221])+|none)$/gi;class TraitActionTag{static tryRun(a,b){function c(c,d){function e(){return"trait"===c}a[c]&&a[c].forEach(f=>{if(!f.name)return;f.name=f.name.trim();const g=f.name.toLowerCase(),h=TraitActionTag.tags[c][g];h?(a[d]=a[d]||[],!0===h?a[d].push(f.name):a[d].push(h)):e()&&g.startsWith("keen ")?(a[d]=a[d]||[],a[d].push("Keen Senses")):e()&&g.startsWith("legendary resistance")?(a[d]=a[d]||[],a[d].push("Legendary Resistances")):e()&&g.endsWith(" absorption")?(a[d]=a[d]||[],a[d].push("Damage Absorption")):b&&b(c,d,g)})}a.traitTags&&(a.traitTags=[]),a.actionTags&&(a.actionTags=[]),c("trait","traitTags"),c("action","actionTags"),c("reaction","actionTags"),a.traitTags&&!a.traitTags.length&&delete a.traitTags,a.actionTags&&!a.actionTags.length&&delete a.actionTags}}TraitActionTag.tags={trait:{"turn immunity":!0,brute:!0,"antimagic susceptibility":!0,"sneak attack":!0,"sneak attack (1/turn)":"Sneak Attack",reckless:!0,"web sense":!0,flyby:!0,pounce:!0,"water breathing":!0,"turn resistance":!0,"turn defiance":"Turn Resistance","turning defiance":"Turn Resistance","turn resistance aura":"Turn Resistance","undead fortitude":!0,aggressive:!0,illumination:!0,rampage:!0,rejuvenation:!0,"web walker":!0,"incorporeal movement":!0,"keen hearing and smell":"Keen Senses","keen sight and smell":"Keen Senses","keen hearing and sight":"Keen Senses","keen hearing":"Keen Senses","keen smell":"Keen Senses","keen senses":!0,"hold breath":!0,charge:!0,"fey ancestry":!0,"siege monster":!0,"pack tactics":!0,regeneration:!0,shapechanger:!0,"false appearance":!0,"spider climb":!0,"sunlight sensitivity":!0,"sunlight hypersensitivity":"Sunlight Sensitivity","light sensitivity":!0,amphibious:!0,"legendary resistance (1/day)":"Legendary Resistances","legendary resistance (2/day)":"Legendary Resistances","legendary resistance (3/day)":"Legendary Resistances","legendary resistance (5/day)":"Legendary Resistances","magic weapon":"Magic Weapons","magic weapons":!0,"magic resistance":!0,"spell immunity":"Magic Resistance",ambush:"Ambusher",ambusher:!0,amorphous:!0,"amorphous form":"Amorphous","death burst":!0,"death throes":"Death Burst","devil's sight":!0,"devil sight":"Devil's Sight","immutable form":!0},action:{multiattack:!0,"frightful presence":!0,teleport:!0,swallow:!0,tentacle:"Tentacles",tentacles:!0},reaction:{parry:!0},legendary:{}};class LanguageTag{static tryRun(a,b){b=b||{};const c=new Set;if(a.languages){if(a.languages=a.languages.map(a=>a.trim()).filter(a=>!TagUtil.isNoneOrEmpty(a)),!a.languages.length)return void delete a.languages;a.languages=a.languages.map(a=>a.replace(/but can(not|'t) speak/ig,"but can't speak")),a.languages.forEach(a=>{b.cbAll&&b.cbAll(a),Object.keys(LanguageTag.LANGUAGE_MAP).forEach(d=>{const e=LanguageTag.LANGUAGE_MAP[d],f=new RegExp(`(^|[^-a-zA-Z])${d}([^-a-zA-Z]|$)`,"g");if(f.exec(a)){if(("XX"===e||"X"===e)&&(a.includes("knew in life")||a.includes("spoke in life")))return;if(/(one|the) languages? of its creator/i.exec(a))return;b.cbTracked&&b.cbTracked(e),c.add(e)}})})}c.size?b.isAppendOnly?((a.languageTags||[]).forEach(a=>c.add(a)),a.languageTags=[...c]):a.languageTags=[...c]:!b.isAppendOnly&&delete a.languageTags}}LanguageTag.LANGUAGE_MAP={Abyssal:"AB",Aquan:"AQ",Auran:"AU",Celestial:"CE",Common:"C","can't speak":"CS",Draconic:"DR",Dwarvish:"D",Elvish:"E",Giant:"GI",Gnomish:"G",Goblin:"GO",Halfling:"H",Infernal:"I",Orc:"O",Primordial:"P",Sylvan:"S",Terran:"T",Undercommon:"U",Aarakocra:"OTH","one additional":"X","Blink Dog":"OTH",Bothii:"OTH",Bullywug:"OTH","one other language":"X","plus six more":"X","plus two more languages":"X","up to five other languages":"X",Druidic:"DU","Giant Eagle":"OTH","Giant Elk":"OTH","Giant Owl":"OTH",Gith:"GTH",Grell:"OTH",Grung:"OTH",Homarid:"OTH","Hook Horror":"OTH","Ice Toad":"OTH",Ixitxachitl:"OTH",Kruthik:"OTH",Netherese:"OTH",Olman:"OTH",Otyugh:"OTH",Primal:"OTH",Sahuagin:"OTH",Sphinx:"OTH",Thayan:"OTH","Thri-kreen":"OTH",Tlincalli:"OTH",Troglodyte:"OTH","Umber Hulk":"OTH",Vegepygmy:"OTH","Winter Wolf":"OTH",Worg:"OTH",Yeti:"OTH",Yikaria:"OTH",all:"XX","all but rarely speaks":"XX","any one language":"X","any two languages":"X","any three languages":"X","any four languages":"X","any five languages":"X","any six languages":"X","one language of its creator's choice":"X","two other languages":"X",telepathy:"TP","thieves' cant":"TC","Thieves' cant":"TC","Deep Speech":"DS",Gnoll:"OTH",Ignan:"IG",Modron:"OTH",Slaad:"OTH","all languages":"XX","any language":"X"};class SenseTag{static tryRun(a,b){if(a.senses)if(a.senses=a.senses.filter(a=>!TagUtil.isNoneOrEmpty(a)),!a.senses.length)delete a.senses;else{const c=new Set;a.senses.map(a=>a.trim().toLowerCase()).forEach(a=>{Object.entries(SenseTag.TAGS).forEach(([b,d])=>{a.includes(b)&&("D"===d&&/\d\d\d ft/.exec(a)?c.add("SD"):c.add(d))}),b&&b(a)}),0===c.size?delete a.senseTags:a.senseTags=[...c]}}}SenseTag.TAGS={blindsight:"B",darkvision:"D",tremorsense:"T",truesight:"U"};class SpellcastingTypeTag{static tryRun(a,b){if(!a.spellcasting)delete a.spellcastingTags;else{const c=new Set;a.spellcasting.forEach(a=>{if(a.name){if(/(^|[^a-zA-Z])psionics([^a-zA-Z]|$)/gi.exec(a.name)&&c.add("P"),/(^|[^a-zA-Z])innate([^a-zA-Z]|$)/gi.exec(a.name)&&c.add("I"),/(^|[^a-zA-Z])form([^a-zA-Z]|$)/gi.exec(a.name)&&c.add("F"),/(^|[^a-zA-Z])shared([^a-zA-Z]|$)/gi.exec(a.name)&&c.add("S"),a.headerEntries){const d=JSON.stringify(a.headerEntries);Object.entries(SpellcastingTypeTag.CLASSES).forEach(([a,e])=>{e.lastIndex=0;const f=e.exec(d);f&&(c.add(a),b&&b(f[0]))})}b&&b(a.name)}}),c.size?a.spellcastingTags=[...c]:delete a.spellcastingTags}}}SpellcastingTypeTag.CLASSES={CB:/(^|[^a-zA-Z])bard([^a-zA-Z]|$)/gi,CC:/(^|[^a-zA-Z])cleric([^a-zA-Z]|$)/gi,CD:/(^|[^a-zA-Z])druid([^a-zA-Z]|$)/gi,CP:/(^|[^a-zA-Z])paladin([^a-zA-Z]|$)/gi,CR:/(^|[^a-zA-Z])ranger([^a-zA-Z]|$)/gi,CS:/(^|[^a-zA-Z])sorcerer([^a-zA-Z]|$)/gi,CL:/(^|[^a-zA-Z])warlock([^a-zA-Z]|$)/gi,CW:/(^|[^a-zA-Z])wizard([^a-zA-Z]|$)/gi};class DamageTypeTag{static _handleProp(a,b,c){a[b]&&a[b].forEach(a=>{if(a.entries){const b=JSON.stringify(a.entries,null,"\t");b.replace(RollerUtil.REGEX_DAMAGE_DICE,(a,b,d,e,f)=>{f.replace(DamageTypeTag._TYPE_REGEX,(a,b)=>c.add(DamageTypeTag._TYPE_LOOKUP[b]))})}})}static tryRun(a){DamageTypeTag._isInit||(DamageTypeTag._isInit=!0,Object.entries(Parser.DMGTYPE_JSON_TO_FULL).forEach(([a,b])=>DamageTypeTag._TYPE_LOOKUP[b]=a));const b=new Set;DamageTypeTag._handleProp(a,"action",b),DamageTypeTag._handleProp(a,"reaction",b),DamageTypeTag._handleProp(a,"trait",b),DamageTypeTag._handleProp(a,"legendary",b),DamageTypeTag._handleProp(a,"variant",b),b.size&&(a.damageTags=[...b])}}DamageTypeTag._isInit=!1,DamageTypeTag._TYPE_REGEX=/(acid|bludgeoning|cold|fire|force|lightning|necrotic|piercing|poison|psychic|radiant|slashing|thunder)/gi,DamageTypeTag._TYPE_LOOKUP={};class MiscTag{static _handleProp(a,b,c){a[b]&&a[b].forEach(a=>{let b=!1;if(a.entries){const d=JSON.stringify(a.entries,null,"\t");d.replace(/{@atk ([^}]+)}/g,(...a)=>{const d=a[1].split(",");d.includes("rw")&&(c.add("RW"),b=!0),d.includes("mw")&&c.add("MW")}),d.replace(/reach (\d+) ft\./g,(...a)=>{5<+a[1]&&c.add("RCH")}),d.replace(/\d+-foot[- ](line|cube|cone|radius|sphere|hemisphere|cylinder)/g,()=>c.add("AOE"))}a.name&&(b&&MiscTag._THROWN_WEAPON_MATCHERS.forEach(b=>a.name.replace(b,()=>c.add("THW"))),MiscTag._RANGED_WEAPON_MATCHERS.forEach(b=>a.name.replace(b,()=>c.add("RNG"))))})}static tryRun(a){const b=new Set;MiscTag._handleProp(a,"action",b),MiscTag._handleProp(a,"trait",b),MiscTag._handleProp(a,"reaction",b),MiscTag._handleProp(a,"legendary",b),b.size?a.miscTags=[...b]:delete a.miscTags}}MiscTag._THROWN_WEAPONS=["dagger","handaxe","javelin","light hammer","spear","trident","dart","net"],MiscTag._THROWN_WEAPON_MATCHERS=MiscTag._THROWN_WEAPONS.map(a=>new RegExp(`(^|[^\\w])(${a})([^\\w]|$)`,"gi")),MiscTag._RANGED_WEAPONS=["light crossbow","shortbow","sling","blowgun","hand crossbow","heavy crossbow","longbow"],MiscTag._RANGED_WEAPON_MATCHERS=MiscTag._RANGED_WEAPONS.map(a=>new RegExp(`(^|[^\\w])(${a})([^\\w]|$)`,"gi"));class SpellcastingTraitConvert{static async pGetSpellData(){const a=await DataUtil.loadJSON(`data/spells/index.json`);return Promise.all(Object.values(a).map(a=>DataUtil.loadJSON(`data/spells/${a}`)))}static init(a){a.reverse().forEach(a=>a.spell.forEach(a=>SpellcastingTraitConvert.SPELL_SRC_MAP[a.name.toLowerCase()]=a.source))}static tryParseSpellcasting(a,b,c){function d(a){function c(a){let c=a.substring(a.indexOf(": ")+2).trim();if(b){const a=a=>{for(a=a.trim();a.startsWith("*")&&a.endsWith("*");)a=a.replace(/^\*(.*)\*$/,"$1");return a},b=c.split(d).map(b=>a(b)).filter(a=>a);for(c=b.join(", ");c.startsWith("*")&&c.endsWith("*");)c=c.replace(/^\*(.*)\*$/,"$1")}return c.split(d).map(a=>e(a))}const d=StrUtil.COMMAS_NOT_IN_PARENTHESES_REGEX;let h=a.name,j={name:h,headerEntries:[f(a.entries[0])]},k=!1;a.entries.forEach((a,b)=>{if(a=a.replace(/,\s*\*/g,",*"),0!==b)if(a.includes("/rest")){k=!0;let b=a.substr(0,1)+(a.includes(" each:")?"e":"");const d=c(a);j.rest||(j.rest={}),j.rest[b]=d}else if(a.includes("/day")){k=!0;let b=a.substr(0,1)+(a.includes(" each:")?"e":"");const d=c(a);j.daily||(j.daily={}),j.daily[b]=d}else if(a.includes("/week")){k=!0;let b=a.substr(0,1)+(a.includes(" each:")?"e":"");const d=c(a);j.weekly||(j.weekly={}),j.weekly[b]=d}else if(a.startsWith("Constant: "))k=!0,j.constant=c(a);else if(a.startsWith("At will: "))k=!0,j.will=c(a);else if(a.includes("Cantrip")){k=!0;const b=c(a);j.spells||(j.spells={0:{spells:[]}}),j.spells[0].spells=b}else if(a.includes(" level")&&a.includes(": ")){k=!0;let b=a.substr(0,1);const d=c(a);j.spells=j.spells||{};const e={};if(a.includes(" slot")){const b=/^(\d)..-(\d).. level \((\d) \d..-level slots?\)/.exec(a);if(b)e.lower=parseInt(b[1]),e.slots=parseInt(b[2]);else{const b=/\((\d) slots?\)/.exec(a);if(!b)throw new Error(`Could not find slot count!`);e.slots=parseInt(b[1])}}e.spells=d,j.spells[b]=e}else k?(!j.footerEntries&&(j.footerEntries=[]),j.footerEntries.push(f(a))):j.headerEntries.push(f(a))}),SpellcastingTraitConvert.mutSpellcastingAbility(j),g.push(j)}function e(a){function b(a){const b=SpellcastingTraitConvert._getSpellSource(a);return`${b&&b!==SRC_PHB?`|${b}`:""}`}a=a.trim();let c=a.indexOf("*"),d=a.indexOf(" (");if(-1!==c){const d=a.substr(0,c);return`{@spell ${d}${b(d)}}*`}if(-1!==d){const c=a.substr(0,d);return`{@spell ${c}${b(c)}}${a.substring(d)}`}return`{@spell ${a}${b(a)}}`}function f(a){return a.replace(/( \+)(\d+)( to hit with spell)/g,(a,b,c,d)=>` {@hit ${c}}${d}`)}let g=[];try{return d(a),{out:g,success:!0}}catch(b){return c&&c(`Failed to parse spellcasting: ${b.message}`),{out:a,success:!1}}}static mutSpellcastingAbility(a){if(a.headerEntries){const b=/strength|dexterity|constitution|charisma|intelligence|wisdom/gi.exec(JSON.stringify(a.headerEntries));b&&(a.ability=b[0].substring(0,3).toLowerCase())}}static _getSpellSource(a){return a&&SpellcastingTraitConvert.SPELL_SRC_MAP[a.toLowerCase()]?SpellcastingTraitConvert.SPELL_SRC_MAP[a.toLowerCase()]:null}}SpellcastingTraitConvert.SPELL_SRC_MAP={};class DiceConvert{static convertTraitActionDice(a){a.entries&&(a.entries=a.entries.filter(a=>!a.trim||a.trim()).map(a=>(a=JSON.stringify(a),a=a.replace(/([-+])?\d+(?= to hit)/g,function(a){const b=a.startsWith("+")?a.replace("+",""):a;return`{@hit ${b}}`}),JSON.parse(DiceConvert._getTaggedString(a)))))}static _getTaggedString(a){return a=a.replace(/{@(?:dice|damage) ([^}]*)}/gi,"$1"),a=a.replace(/((\s*[-+]\s*)?(([1-9]\d*)?d([1-9]\d*)(\s*?[-+×x*÷/]\s*?(\d,\d|\d)+(\.\d+)?)?))+/gi,(...a)=>{const b=a[0].replace(/([^0-9d.,])/gi," $1 ").replace(/\s+/g," ");return`{@dice ${b}}`}),a=a.replace(/(\d+)( \({@dice )([-+0-9d ]*)(}\) [a-z]+( or [a-z]+)? damage)/ig,(...a)=>a[0].replace(/{@dice /gi,"{@damage ")),a}static cleanHpDice(a){a.hp&&a.hp.formula&&(a.hp.formula=a.hp.formula.replace(/\s+/g,"").replace(/([^0-9d])/gi," $1 "))}}class RechargeConvert{static tryConvertRecharge(a,b,c){a.name&&(a.name=a.name.replace(/\((Recharge )(\d.*?)\)$/gi,(...d)=>{b&&b(d[2]);const e=d[2][0];return"6"===e?`{@recharge}`:isNaN(+e)?(c&&c(a.name),d[0]):`{@recharge ${e}}`}))}}class SpeedConvert{static _splitSpeed(a){let b,d=[],e="",f=0;for(let c=0;c<a.length;++c)b=a.charAt(c),","===b?0===f&&(d.push(e),e=""):"("===b?(f++,e+=b):")"===b?(f--,e+=b):e+=b;return e&&d.push(e),d.map(a=>a.trim()).filter(a=>a)}static _tagHover(a){a.speed&&a.speed.fly&&a.speed.fly.condition&&(a.speed.fly.condition=a.speed.fly.condition.trim(),a.speed.fly.condition.toLowerCase().includes("hover")&&(a.speed.canHover=!0))}static tryConvertSpeed(a,b){if("string"==typeof a.speed){let c=a.speed.toLowerCase().trim().replace(/^speed:?\s*/,"");const d={};let e=!1;SpeedConvert._splitSpeed(c.toLowerCase()).map(a=>a.trim()).forEach(a=>{const b=/^(\w+?\s+)?(\d+)\s*ft\.?( .*)?$/.exec(a);return b?void(b[1]=b[1]?b[1].trim():"walk",SpeedConvert._SPEED_TYPES.has(b[1])?b[3]?d[b[1]]={number:+b[2],condition:b[3].trim()}:d[b[1]]=+b[2]:e=!0):void(e=!0)}),Object.values(d).filter(a=>0!=(null==a.number?a:a.number)%5).length&&(d.INVALID_SPEED=!0),e&&(d.UNPARSED_SPEED=c,b&&b(`Speed requires manual conversion: "${c}"`)),a.speed=d,SpeedConvert._tagHover(a)}}}SpeedConvert._SPEED_TYPES=new Set(["walk","fly","swim","climb","burrow"]);class TextClean{static getCleanedJson(a){return a=a.replace(TextClean.REPLACEMENT_REGEX,a=>TextClean.REPLACEMENTS[a]),a.replace(/\s*(\\u2014|\\u2013)\s*/g,"$1")}static getReplacedQuotesText(a){return a.replace(/’/g,"'").replace(/[“”]/g,`"`).replace(/…/g,`...`)}}TextClean.REPLACEMENTS={"—":"\\u2014","–":"\\u2013","−":"\\u2212","’":"'","“":"\\\"","”":"\\\"","…":"..."},TextClean.REPLACEMENT_REGEX=new RegExp(Object.keys(TextClean.REPLACEMENTS).join("|"),"g");class ConvertUtil{static isNameLine(a){const b=a.split(/[.!?]/);if(1===b.length)return!1;const c=ConvertUtil.getWithoutParens(b[0]),d=new RegExp(`^(${StrUtil.TITLE_LOWER_WORDS.join("|")})$`,"i"),e=c.split(/([ ,;:]+)/g),f=e.filter(a=>{const b=d.test(a.trim());return d.lastIndex=0,!b}),g=f.join("");return g.toTitleCase()===g}static getWithoutParens(a){let b,c=!1,d="";const e=a.length;for(let f=0;f<e;++f)switch(b=a[f],b){case")":{let a=-1;for(let b=d.length-1;0<=b;--b)if("("===d[b]){a=b;break}~a?(d=d.substring(0,a),c=!0):d+=")";break}case" ":c?c=!1:d+=" ";break;default:c=!1,d+=b;}return d}}"undefined"!=typeof module&&(module.exports={AcConvert,TagAttack,TagHit,TagDc,TagCondition,AlignmentConvert,TraitActionTag,LanguageTag,SenseTag,SpellcastingTypeTag,DamageTypeTag,MiscTag,TextClean,SpellcastingTraitConvert,DiceConvert,RechargeConvert,SpeedConvert});