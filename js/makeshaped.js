'use strict';class ShapedConverter{static get SOURCE_INFO(){return{bestiary:{dir:"data/bestiary/",inputProp:"monsterInput"},spells:{dir:"data/spells/",inputProp:"spellInput"}}}pGetInputs(){return this._inputPromise||(this._inputPromise=this._pGetInputs()),this._inputPromise}async _pGetInputs(){const a=this.constructor.SOURCE_INFO,b=[`${a.bestiary.dir}index.json`,`${a.spells.dir}index.json`,`${a.bestiary.dir}srd-monsters.json`,`${a.spells.dir}srd-spells.json`,`${a.spells.dir}roll20.json`,`${a.bestiary.dir}meta.json`];this._inputPromise=Promise.all(b.map(a=>DataUtil.loadJSON(a)));const c=(await this._inputPromise).flat();ShapedConverter.bestiaryIndex=c[0],a.bestiary.fileIndex=c[0],a.spells.fileIndex=c[1];const d={};d._srdMonsters=c[2].monsters,d._srdSpells=c[3].spells,d._srdSpellRenames=c[3].spellRenames,d._additionalSpellData={},c[4].spell.forEach(a=>d._additionalSpellData[a.name]=Object.assign(a.data,a.shapedData)),d._legendaryGroup={},c[5].legendaryGroup.forEach(a=>{d._legendaryGroup[a.source]=d._legendaryGroup[a.source]||{},d._legendaryGroup[a.source][a.name]=a}),Object.defineProperties(d,{_srdMonsters:{writable:!1,enumerable:!1},_srdSpells:{writable:!1,enumerable:!1},_srdSpellRenames:{writable:!1,enumerable:!1},_additionalSpellData:{writable:!1,enumerable:!1},_legendaryGroup:{writable:!1,enumerable:!1}}),Object.values(a).reduce((a,b)=>(Object.keys(b.fileIndex).forEach(c=>{const d=this.constructor.getInput(a,c,Parser.SOURCE_JSON_TO_FULL[c]);d[b.inputProp]=`${b.dir}${b.fileIndex[c]}`}),a),d);const e=await BrewUtil.pAddBrewData();return this.addBrewData(d,e),d}addBrewData(a,b){b.spell&&b.spell.length&&b.spell.forEach(b=>{const c=this.constructor.getInput(a,b.source,BrewUtil.sourceJsonToFull(b.source));c.spellInput=c.spellInput||[],c.spellInput.push(b)}),b.monster&&b.monster.length&&b.monster.forEach(b=>{const c=this.constructor.getInput(a,b.source,BrewUtil.sourceJsonToFull(b.source));c.monsterInput=c.monsterInput||[],c.monsterInput.push(b)}),b.legendaryGroup&&b.legendaryGroup.length&&b.legendaryGroup.forEach(b=>{a._legendaryGroup[b.source]=a._legendaryGroup[b.source]||{},a._legendaryGroup[b.source][b.name]||(a._legendaryGroup[b.source][b.name]=b)})}static getInput(a,b,c){return a[b]=a[b]||{name:c,key:b,dependencies:b===SRC_PHB?["SRD"]:["Player's Handbook"],classes:{}},a[b]}async pGenerateShapedJS(a){const b=await this.pGetInputs(),c=[];if(a.forEach(a=>{const d=b[a];isString(d.monsterInput)&&c.push({url:d.monsterInput,key:a}),isString(d.spellInput)&&c.push({url:d.spellInput,key:a})}),c.length){const a=MiscUtil.copy(c),d=(await Promise.all(a.map(a=>DataUtil.loadJSON(a.url)))).flat();d.forEach((a,d)=>{const e=c[d].key;a.spell&&(b[e].spellInput=a.spell),a.monster&&(b[e].monsterInput=a.monster),c[d].doNotConvert&&(b[e].doNotConvert=!0)})}this.constructor.convertData(b);const d=a.map(a=>`ShapedScripts.addEntities(${JSON.stringify(b[a].converted,this.constructor.serialiseFixer)})`).join("\n");return`on('ready', function() {\n${d}\n});`}static makeSpellList(a){return`${a.map(this.fixLinks).join(", ")}`}static get INNATE_SPELLCASTING_RECHARGES(){return{daily:"day",rest:"rest",weekly:"week"}}static innateSpellProc(a){return Object.keys(a).filter(a=>!["headerEntries","headerWill","name","footerEntries","ability","hidden"].includes(a)).map(b=>{const c=a[b];if("will"===b)return`At will: ${this.makeSpellList(c)}`;if("constant"===b)return`Constant: ${this.makeSpellList(c)}`;if(this.INNATE_SPELLCASTING_RECHARGES[b]){const a=this.INNATE_SPELLCASTING_RECHARGES[b];return Object.keys(c).map(b=>{const d=c[b],e=b.slice(0,1),f=b.endsWith("e")&&1<d.length;return`${e}/${a}${f?" each":""}: ${this.makeSpellList(d)}`}).sort((c,a)=>parseInt(a,10)-parseInt(c,10))}if("spells"===b)return this.processLeveledSpells(c);throw new Error("Unrecognised spellUseInfo "+b)}).reduce(this.flattener,[])}static processLeveledSpells(a){return Object.keys(a).map(b=>{if("hidden"===b)return null;if("will"===b)return`At-will: ${this.makeSpellList(a[b])}`;else{const c=parseInt(b,10),d=a[c];return`${Parser.spLevelToFullLevelText(c)} (${this.slotString(d.slots)}): ${this.makeSpellList(d.spells)}`}}).filter(Boolean)}static normalSpellProc(a){return this.processLeveledSpells(a.spells)}static slotString(a){return void 0===a?"at will":1===a?"1 slot":`${a} slots`}static processChallenge(a){if("Unknown"===a||null==a)return 0;const b=a.match(/(\d+)(?:\s?\/\s?(\d+))?/);if(!b)throw new Error("Bad CR "+a);return b[2]?parseInt(b[1],10)/parseInt(b[2],10):parseInt(b[1],10)}static fixLinks(a){return a.replace(/{@filter ([^|]+)[^}]+}/g,"$1").replace(/{@hit (\d+)}/g,"+$1").replace(/{@chance (\d+)[^}]+}/g,"$1 percent").replace(/{@recharge(?: (\d))?}/g,(a,b)=>`(Recharge ${b?`${+b}\u2013`:""}6)`).replace(/{(@atk [A-Za-z,]+})/g,(a,b)=>Renderer.attackTagToFull(b)).replace(/{@h}/g,"Hit: ").replace(/{@dc (\d+)}/g,"DC $1").replace(/{@\w+ ((?:[^|}]+\|?){0,3})}/g,(a,b)=>{const c=b.split("|");return 3===c.length?c[2]:c[0]}).replace(/(d\d+)([+-])(\d)/g,"$1 $2 $3")}static makeTraitAction(a){const b=this.fixLinks(a).match(/([^(]+)(?:\(([^)]+)\))?/);if(b&&b[2]){const a=b[2].match(/^(?:(.*), )?(\d(?: minute[s]?)?\/(?:Day|Turn|Rest|Hour|Week|Month|Night|Long Rest|Short Rest)|Recharge \d(?:\u20136)?|Recharge[s]? [^),]+)(?:, ([^)]+))?$/i);if(a){let c=b[1].trim();const d=a[1]||a[3];return d&&(c+=` (${d})`),{name:c,text:"",recharge:a[2]}}}return{name:a}}static processStatblockSection(a){return a.map(a=>{const b=this.makeTraitAction(a.name);if(this.SPECIAL_TRAITS_ACTIONS[b.name])return this.SPECIAL_TRAITS_ACTIONS[b.name](b,a.entries);const c=a.entries.map(a=>{if(isObject(a)){if(a.items)return isObject(a.items[0])?a.items.map(a=>({name:a.name.replace(/^([^.]+)\.$/,"$1"),text:this.fixLinks(a.entry)})):a.items.map(a=>`â€¢ ${this.fixLinks(a)}`).join("\n");if(a.entries){const b="inline"===a.type?"":"\n";return a.entries.map(a=>isString(a)?a:a.text).join(b)}}else return this.fixLinks(a)}).reduce(this.flattener,[]);return b.text=c.filter(isString).join("\n"),[b].concat(c.filter(isObject))}).reduce(this.flattener,[])}static processSpecialList(a,b){a.text=this.fixLinks(b[0]);let c=b.slice(1);return 1===c.length&&"list"===c[0].type&&(c=c[0].items.map(a=>"item"===a.type?`${a.name}. ${a.entries?a.entries.join("\n"):a.entry}`:a)),c.reduce((a,b)=>{const c=b.match(/^(?:\d+\. )?([A-Z][a-z]+(?: [A-Z][a-z]+)*). (.*)$/);return c?a.push({name:c[1],text:this.fixLinks(c[2])}):a.last().text=a.last().text+"\n"+b,a},[a])}static get SPECIAL_TRAITS_ACTIONS(){return{Roar:this.processSpecialList.bind(this),"Eye Rays":this.processSpecialList.bind(this),"Eye Ray":this.processSpecialList.bind(this),Gaze:this.processSpecialList.bind(this),"Call the Blood":this.processSpecialList.bind(this)}}static processHP(a,b){b.HP=a.hp.special?a.hp.special:`${a.hp.average} (${a.hp.formula.replace(/(\d)([+-])(\d)/,"$1 $2 $3")})`}static processAC(a){function b(a,b){return`${a}${a.length?", ":""}${b}`}return a.reduce((a,c)=>{if(isNumber(c))return b(a,c);if(c.condition&&c.braces)return`${a} (${c.ac} ${this.fixLinks(c.condition)})`;let d=`${c.ac}`;return c.from&&(d+=` (${c.from.map(this.fixLinks).join(", ")})`),c.condition&&(d+=` ${this.fixLinks(c.condition)}`),b(a,d)},"")}static processSkills(a,b){if(b.skills=Object.keys(a.skill).filter(a=>"other"!==a).map(b=>`${b.toTitleCase()} ${a.skill[b]}`).join(", "),a.skill.other){const b=this.objMap(a.skill.other[0].oneOf,(a,b)=>`${b.toTitleCase()} ${a}`).join(", ");(a.trait=a.trait||[]).push({name:"Additional Skill Proficiencies",entries:[`The ${a.name} also has one of the following skill proficiencies: ${b}`]})}}static getSpellcastingProcessor(a){if(a.daily||a.will||a.headerWill)return this.innateSpellProc.bind(this);if(a.spells)return this.normalSpellProc.bind(this);if(a.hidden)return null;throw new Error(`Unrecognised type of spellcasting object: ${a.name}`)}static processMonster(a,b){const c={};c.name=a.name,c.size=Parser.sizeAbvToFull(a.size),c.type=Parser.monTypeToFullObj(a.type).asText.replace(/^[a-z]/,a=>a.toLocaleUpperCase()),c.alignment=a.alignment?Parser.alignmentListToFull(a.alignment).toLowerCase():"Unknown",c.AC=this.processAC(a.ac),this.processHP(a,c),c.speed=Parser.getSpeedString(a),c.strength=a.str,c.dexterity=a.dex,c.constitution=a.con,c.intelligence=a.int,c.wisdom=a.wis,c.charisma=a.cha,a.save&&(c.savingThrows=this.objMap(a.save,(a,b)=>`${b.toTitleCase()} ${a}`).join(", ")),a.skill&&this.processSkills(a,c),a.vulnerable&&(c.damageVulnerabilities=Parser.monImmResToFull(a.vulnerable)),a.resist&&(c.damageResistances=Parser.monImmResToFull(a.resist)),a.immune&&(c.damageImmunities=Parser.monImmResToFull(a.immune)),a.conditionImmune&&(c.conditionImmunities=Parser.monCondImmToFull(a.conditionImmune)),c.senses=(a.senses||[]).join(", "),c.languages=(a.languages||[]).join(", "),c.challenge=this.processChallenge(a.cr?a.cr.cr||a.cr:null);const d=[],e=[],f=[];a.trait&&d.push.apply(d,this.processStatblockSection(a.trait)),a.spellcasting&&a.spellcasting.forEach(a=>{const b=this.getSpellcastingProcessor(a);if(null!=b){const c=b(a);c.unshift(this.fixLinks(a.headerEntries[0])),a.footerEntries&&c.push.apply(c,a.footerEntries);const e=this.makeTraitAction(a.name);e.text=c.join("\n"),d.push(e)}}),a.action&&e.push.apply(e,this.processStatblockSection(a.action)),a.reaction&&f.push.apply(f,this.processStatblockSection(a.reaction));const g=(a,b,c,f)=>{const g=this.makeTraitAction(a);g.name="Variant: "+g.name;const h=b.match(/{@hit|Attack:|{@atk/);g.text=this.fixLinks(b),g.recharge&&!b.match(/bonus action/)||f||h?e.push(g):d.push(g)},h=(a,b)=>{if(isString(a))return a;const c=`${(a.entries||a.headerEntries).map(a=>h(a)).join("\n")}`;return b?c:`${a.name}. ${c}`};if(a.variant&&"Shadow Mastiff"!==a.name&&a.variant.forEach(a=>{const b=a.name;if(a.entries.every(a=>isString(a)||"entries"!==a.type)){const d=a.entries.map(a=>{if(isString(a))return a;if("table"===a.type)return this.processTable(a);if("list"===a.type)return a.items.map(a=>`${a.name} ${a.entry}`).join("\n");else{}}).join("\n");g(b,d,c)}else if(a.entries.find(a=>"entries"===a.type)){let d=!1;a.entries.forEach(a=>{isObject(a)?g(a.name||b,h(a,!0),c,d):d=!!a.match(/action options?[.:]/)})}}),d.length&&(c.traits=d),e.length&&(c.actions=e),f.length&&(c.reactions=f),a.legendary&&(c.legendaryPoints=a.legendaryActions||3,c.legendaryActions=a.legendary.map(a=>{if(!a.name)return null;const b={},c=a.name.match(/([^(]+)(?:\s?\((?:Costs )?(\d(?:[-\u2013]\d)?) [aA]ctions(?:, ([^)]+))?\))?/);return c&&c[2]?(b.name=c[1].trim()+(c[3]?` (${c[3]})`:""),b.text="",b.cost=parseInt(c[2],10)):(b.name=a.name,b.text="",b.cost=1),b.text=this.fixLinks(a.entries.join("\n")),b}).filter(a=>!!a)),a.legendaryGroup&&(b[a.legendaryGroup.source]||{})[a.legendaryGroup.name]){const d=b[a.legendaryGroup.source][a.legendaryGroup.name],e=d.lairActions;e&&(e.every(isString)?c.lairActions=e.map(this.fixLinks):c.lairActions=e.filter(isObject)[0].items.map(this.itemRenderer)),d.regionalEffects&&(c.regionalEffects=d.regionalEffects.filter(isObject)[0].items.map(this.itemRenderer),c.regionalEffectsFade=this.fixLinks(d.regionalEffects.filter(isString).last()))}return a.environment&&0<a.environment.length&&(c.environments=a.environment.sort((c,a)=>c.localeCompare(a)).map(a=>a.toTitleCase())),c}static get itemRenderer(){return a=>this.fixLinks(isObject(a)?`${a.name}. ${a.entries.join("\n")}`:a)}static padInteger(a){return 10>a&&0<=a?`0${a}`:`${a}`}static processSpellComponents(a,b){a=a||{};const c={};a.v&&(c.verbal=!0),a.s&&(c.somatic=!0),a.m&&(c.material=!0,!0!==a.m&&(c.materialMaterial=a.m.text||a.m)),b.components=c}static processSpellDuration(a,b){switch(a.type){case"special":b.duration="Special";break;case"instant":b.duration="Instantaneous";break;case"timed":b.concentration=a.concentration,b.duration=`${a.concentration?"up to ":""}${a.duration.amount} ${a.duration.type}${1<a.duration.amount?"s":""}`;break;case"permanent":b.duration=a.ends?`Until ${a.ends.filter(a=>"dispel"===a||"trigger"===a).map(a=>"dispel"===a?"dispelled":a).map(a=>"trigger"===a?"triggered":a).sort().join(" or ")}`:"Special";}}static processSpellEntries(a,b){const c=a=>isString(a)?a:"table"===a.type?this.processTable(a):"list"===a.type?a.items.map(a=>`- ${a}`).join("\n"):"homebrew"===a.type?a.entries?a.entries.map(c).join("\n"):"":`***${a.name}.*** ${a.entries.map(c).join("\n")}`;let d=a;isString(a.last())&&(a.last().match(/damage increases(?: by (?:{[^}]+}|one die))? when you reach/)||a.last().match(/creates more than one beam when you reach/))&&(b.description="",d=a.slice(0,-1),b.higherLevel=this.fixLinks(a.last())),b.description=this.fixLinks(d.map(c).join("\n"))}static processTable(a){const b=a=>{if(isString(a))return a;return a.roll?a.roll.exact||`${this.padInteger(a.roll.min)}\\u2013${this.padInteger(a.roll.max)}`:void 0},c=[a.colLabels];c.push.apply(c,a.rows);const d=c.map(a=>`| ${a.map(b).join(" | ")} |`),e=a.colStyles?a.colStyles.map(a=>{if(a.includes("text-center"))return":----:";return a.includes("text-right")?"----:":":----"}):a.colLabels.map(()=>":----"),f=`|${e.join("|")}|`;d.splice(1,0,f);const g=a.caption?`##### ${a.caption}\n`:"";return`${g}${d.join("\n")}`}static addExtraSpellData(a,b){b["Spell Attack"]&&(a.attack={type:b["Spell Attack"].toLocaleLowerCase()}),b.Save&&(a.save={ability:b.Save},b["Save Success"]&&(a.save.saveSuccess=b["Save Success"].toLocaleLowerCase()));const c=b.primaryDamageCondition===b.secondaryDamageCondition?this.SECONDARY_DAMAGE_OUTPUTS_NAMES:this.PRIMARY_DAMAGE_OUTPUT_NAMES;if([[this.PRIMARY_DAMAGE_PROP_NAMES,this.PRIMARY_DAMAGE_OUTPUT_NAMES],[this.SECONDARY_DAMAGE_PROP_NAMES,c]].forEach(c=>{const d=c[0],e=c[1];if(b[d.damage]&&"Effect"!==b[d.damageType])switch(b[d.condition]){case"save":this.processDamageInfo(b,a.save,d,e);break;case"attack":this.processDamageInfo(b,a.attack,d,e);break;case"auto":a.damage=a.damage||{},this.processDamageInfo(b,a.damage,d,e);break;default:throw new Error("Missing "+d.condition+" for spell "+a.name);}}),b.Healing){a.heal={};const c=b.Healing.match(/^(\d+d\d+)?(?:\s?\+\s?)?(\d+)?$/);c?(c[1]&&(a.heal.heal=c[1]),c[2]&&(a.heal.bonus=parseInt(c[2],10))):a.heal.heal=b.Healing,"Yes"===b["Add Casting Modifier"]&&(a.heal.castingStat=!0),b["Higher Spell Slot Dice"]&&b.Healing.match(/\d+(?:d\d+)/)&&(a.heal.higherLevelDice=parseInt(b["Higher Spell Slot Dice"],10)),b["Higher Level Healing"]&&(a.heal.higherLevelAmount=parseInt(b["Higher Level Healing"],10))}}static get PRIMARY_DAMAGE_PROP_NAMES(){return{damage:"Damage",damageProgression:"Damage Progression",damageType:"Damage Type",higherLevel:"Higher Spell Slot Dice",castingStat:"Add Casting Modifier",condition:"primaryDamageCondition"}}static get PRIMARY_DAMAGE_OUTPUT_NAMES(){return{outputDamage:"damage",outputDamageBonus:"damageBonus",outputDamageType:"damageType",outputHigherLevel:"higherLevelDice",outputCastingStat:"castingStat"}}static get SECONDARY_DAMAGE_PROP_NAMES(){return{damage:"Secondary Damage",damageType:"Secondary Damage Type",damageProgression:"Secondary Damage Progression",higherLevel:"Secondary Higher Spell Slot Dice",castingStat:"Secondary Add Casting Modifier",condition:"secondaryDamageCondition"}}static get SECONDARY_DAMAGE_OUTPUTS_NAMES(){return{outputDamage:"secondaryDamage",outputDamageBonus:"secondaryDamageBonus",outputDamageType:"secondaryDamageType",outputHigherLevel:"higherLevelSecondaryDice",outputCastingStat:"secondaryCastingStat"}}static processDamageInfo(a,b,c,d){if(a[c.damage]){if(a[c.damageProgression])b[d.outputDamage]="Cantrip Dice"===a[c.damageProgression]?"[[ceil((@{level} + 2) / 6)]]"+a[c.damage].replace(/\d+(d\d+)/,"$1"):a[c.damage];else{const e=a[c.damage].match(/^(\d+d\d+)?(?:\s?\+\s?)?(\d+)?$/);e?(e[1]&&(b[d.outputDamage]=e[1]),e[2]&&(b[d.outputDamageBonus]=e[2])):b[d.outputDamage]=a[c.damage]}if(a[c.damageType]&&(b[d.outputDamageType]=a[c.damageType].toLocaleLowerCase()),a[c.higherLevel]){const e=a[c.higherLevel].includes(".")?parseFloat:parseInt;b[d.outputHigherLevel]=e(a[c.higherLevel])}"Yes"===a[c.castingStat]&&(b[d.outputCastingStat]=!0)}}static processHigherLevel(a,b){a&&a.length&&(b.higherLevel=this.fixLinks((a[0].entries||a).join("\n")))}static processSpell(a,b){const c={name:a.name,level:a.level,school:Parser.spSchoolAndSubschoolsAbvsToFull(a.school,a.subschools)};return a.meta&&a.meta.ritual&&(c.ritual=!0),Object.assign(c,{castingTime:Parser.getTimeToFull(a.time[0]),range:Parser.spRangeToFull(a.range)}),this.processSpellComponents(a.components,c),this.processSpellDuration(a.duration[0],c),this.processSpellEntries(a.entries,c),this.processHigherLevel(a.entriesHigherLevel,c),b[a.name]&&this.addExtraSpellData(c,b[a.name]),c}static serialiseFixer(a,b){if(isString(b))return b.replace(/'/g,"\u2019").replace(/([\s(])"(\w)/g,"$1\u201C$2").replace(/([\w,.])"/g,"$1\u201D");if(isObject(b)){if(b.recharge)return Object.assign({name:b.name,recharge:b.recharge},b);if(b.cost)if(1===b.cost)delete b.cost;else return Object.assign({name:b.name,cost:b.cost},b)}return b}static convertData(a){const b={},c=a._srdMonsters,d=a._srdSpells,e=a._srdSpellRenames,f=a._additionalSpellData,g=a._legendaryGroup,h=Object.values(a).filter(a=>!a.converted&&(isObject(a.monsterInput)||isObject(a.spellInput))&&!a.doNotConvert);let i=[];Object.values(a).forEach(a=>{a.monsterInput&&(i=i.concat(a.monsterInput))}),h.forEach(h=>{h.monsterInput&&(h.monsterInput.legendaryGroup&&h.monsterInput.legendaryGroup.forEach(a=>g[a.name]=a),h.monsters=h.monsterInput.map(a=>{try{const b=this.processMonster(a,g);if(c.includes(a.name)){const a=(({name:a,lairActions:b,regionalEffects:c,regionalEffectsFade:d})=>({name:a,lairActions:b,regionalEffects:c,regionalEffectsFade:d}))(b);return 1<Object.values(a).filter(a=>!!a).length?a:null}return b}catch(b){throw new Error("Error with monster "+a.name+" in file "+h.name+": "+b.toString()+b.stack)}}).filter(a=>!!a).sort((c,a)=>c.name.localeCompare(a.name))),h.spellInput&&(h.spells=h.spellInput.map(c=>{if(b[c.name]=c.level,c.classes.fromClassList.forEach(b=>{if((d.includes(c.name)||d.includes(e[c.name]))&&b.source===SRC_PHB)return;const f=e[c.name]||c.name,g=b.source===SRC_PHB?h:a[b.source];g&&(g.classes=g.classes||{},g.classes[b.name]=g.classes[b.name]||{archetypes:[],spells:[]},g.classes[b.name].spells.push(f))}),(c.classes.fromSubclass||[]).forEach(b=>{if(["Life","Devotion","Land","Fiend"].includes(b.subclass.name))return;if(!a[b.class.source])return;const d=b.subclass.source===SRC_PHB?h:a[b.subclass.source];if(!d)return;d.classes[b.class.name]=d.classes[b.class.name]||{archetypes:[],spells:[]};const e=b.subclass.subSubclass||b.subclass.name;let f=d.classes[b.class.name].archetypes.find(a=>a.name===e);f||(f={name:e,spells:[]},d.classes[b.class.name].archetypes.push(f)),f.spells.push(c.name)}),d.includes(c.name))return null;if(e[c.name])return{name:e[c.name],newName:c.name};try{return this.processSpell(c,f)}catch(a){throw new Error(`Error with spell ${c.name} in file ${h.name}:${a.toString()}${a.stack}`)}}).filter(a=>!!a).sort((c,a)=>c.name.localeCompare(a.name)))});const j=(a,c)=>{const d=b[a]-b[c];return 0==d?a.localeCompare(c):d};h.forEach(a=>{a.converted={name:a.name,dependencies:a.dependencies,version:"2.0.0"},a.classes&&!isEmpty(a.classes)&&(a.converted.classes=Object.keys(a.classes).map(b=>{const c=a.classes[b];return c.spells&&0<c.spells.length?c.spells.sort(j):delete c.spells,0===c.archetypes.length?delete c.archetypes:(c.archetypes.sort((c,a)=>c.name.localeCompare(a.name)),c.archetypes.forEach(a=>a.spells.sort(j))),Object.assign({name:b},c)}).sort((c,a)=>c.name.localeCompare(a.name))),a.monsters&&0<a.monsters.length&&(a.converted.monsters=a.monsters),a.spells&&0<a.spells.length&&(a.converted.spells=a.spells)})}static flattener(a,b){return Array.isArray(b)?a.push(...b):a.push(b),a}static objMap(a,b){return Object.keys(a).map(c=>b(a[c],c,a))}}function rebuildShapedSources(){shapedConverter.pGetInputs().then(a=>Object.values(a).sort((c,a)=>"Player's Handbook"===c.name?-1:"Player's Handbook"===a.name?1:c.name.localeCompare(a.name))).then(a=>{const b={};b[SRC_PHB]=!0,$(".shaped-source").each((a,c)=>{const d=$(c);d.prop("checked")&&(b[d.val()]=!0),d.parent().parent().remove()}),a.forEach(a=>{const c=a.key===SRC_PHB?"disabled=\"disabled\" ":"",d=b[a.key]?"checked=\"checked\" ":"";$("#sourceList").append($(`<li><label class="shaped-label"><input class="shaped-source" type="checkbox" ${c}${d} value="${a.key}"><span>${a.name}</span></label></li>`))})}).catch(a=>{alert(`${a}\n${a.stack}`),setTimeout(()=>{throw a})})}window.onload=function(){ExcludeUtil.pInitialise(),window.handleBrew=a=>{shapedConverter.pGetInputs().then(b=>{shapedConverter.addBrewData(b,a),rebuildShapedSources()}).catch(a=>{alert(`${a}\n${a.stack}`),setTimeout(()=>{throw a},0)})},window.removeBrewSource=a=>{shapedConverter.pGetInputs().then(b=>{delete b[a],rebuildShapedSources()})},window.shapedConverter=new ShapedConverter,rebuildShapedSources(),BrewUtil.makeBrewButton("manage-brew");const a=$(`<button class="btn btn-primary">Prepare JS</button>`);$(`#buttons`).append(a),a.on("click",()=>{const a=$(".shaped-source:checked").map((a,b)=>b.value).get();shapedConverter.pGenerateShapedJS(a).then(a=>{$("#shapedJS").val(a),$("#copyJS").removeAttr("disabled")}).catch(a=>{alert(`${a}\n${a.stack}`),setTimeout(()=>{throw a},0)})}),$("#copyJS").on("click",()=>{const a=$("#shapedJS");a.select(),document.execCommand("Copy"),JqueryUtil.showCopiedEffect($("#copyJS"))}),$(`#selectAll`).change(function(){$(`.shaped-source:not([disabled])`).prop("checked",$(this).prop("checked"))})};